import time
import numpy as np

# Define the constants
d_solid = 0.000348
k_gas = 0.02
vel = 0.44
Pr = 0.88625
Re = 10.2936
eg = 0.744461

# Start the time calculation
start_time = time.time()

# Prepare the input data
input_data = np.array([eg, Pr, Re]).reshape(1, -1)  # Reshaped to be 2D (1 sample, 3 features)

# Define ReLU function
def relu(x):
    return np.maximum(0, x)

# Function to calculate the output of each layer
def calculate_layer_output(input, weights, biases, apply_relu):
    layer_output = np.dot(input, weights) + biases
    if apply_relu:
        return relu(layer_output)
    else:
        return layer_output

# Manually performing the forward pass
def forward_pass(input):
    # Define weights and biases for each layer
    
    # Input layer (3 neurons) to hidden layer (16 neurons)
    layer_0_weights = np.array([
        [-0.25950536,  0.05051898, -0.9491552],
        [-0.10235794,  0.6063761,  -0.00874649],
        [-0.818455,   -0.3753639,  -0.06115391],
        [-0.17342341, -0.8177767,  -0.68938094],
        [-0.2386257,  -0.02806783, -0.27236846],
        [ 0.52587694, -0.16404015,  0.7763493],
        [ 0.57404965,  0.13744289, -1.1322622],
        [ 1.1471795,   0.7510456,   0.087053],
        [ 0.4780813,   0.08438832,  0.99632823],
        [ 0.6661001,  -0.50537854, -0.46870416],
        [-0.06163907, -0.29280907,  0.494381],
        [ 0.039782,    0.12932771,  0.15269995],
        [ 0.26491767, -0.08348555,  0.32963008],
        [-0.4648143,  -0.03316402, -0.47043556],
        [ 0.24266432,  0.29735553, -0.14122635],
        [-0.41421247, -0.48207814, -0.18720296]
    ])  # Shape (16, 3)
    
    layer_1_weights = np.array([
        [-0.468588,   0.30622894, -0.34558067,  0.4218775,  -0.5348234,  -0.42118332,  0.33258724,  0.42416778, -0.25616217, -0.5241033,   0.59568655, -0.37037504,  0.2874923,   0.01090507,  0.21898067,  0.52594954],
        [ 0.35261345, -0.571674,  -0.03861244, -0.08583701, -0.01735992,  0.30727673,  0.2869097,   0.3307493,  -0.2927127,   0.3627665,   0.4738319,  -0.36809123, -0.15762994,  0.26924485, -0.12223637, -0.02942203],
        [-0.10202694,  0.3949331,  -0.6419753,  -0.23841739,  0.4618428,  -0.09809536, -0.23058283, -0.26287493, -0.02303803, -0.13554294,  0.83283716,  0.3281505,  -0.04111979,  0.7677566,   0.21125638,  0.77486324],
        [-0.01553202,  0.09128368,  0.5185386,  -0.17532527, -0.16908528, -0.00075114, -0.25561905,  0.45202076, -0.32483172, -0.34305632,  0.12013006,  0.17166805,  0.4580716,  -0.06407595, -0.00953567, -0.43439794],
        [-0.2480098,   0.11798064, -0.28576887, -0.35647535, -0.02738313,  0.3708227,  -0.18777561,  0.12031736, -0.10197318, -0.3054911,  -0.28687406,  0.39606833,  0.3639822,   0.10983801,  0.25806105, -0.30100822],
        [-0.1241194,   0.05475572,  0.32216153, -0.3323524,   0.03980596,  0.5263553,  -0.2534654,   0.6254409,   0.17079568,  0.16071928,  0.37447897, -0.20601082,  0.062216,    0.26700756, -0.46847367, -0.00492439],
        [ 0.37535107,  0.23526037, -0.4577142,  -0.11824811,  0.3385594,  -0.21454227, -0.27305257, -0.04614282, -0.1289872,   0.4007045,  -0.13917148, -0.38152874,  0.20255685, -0.48307037, -0.05323279, -0.39628577],
        [-0.46797,     0.18754733,  0.00229526,  0.24333501,  0.3147925,  -0.36645496, -0.03906357, -0.30739248,  0.23988998,  0.00045478344, -0.34270835,  0.3423562,  -0.088960648, 0.31219578,  0.35465312,  0.49239469]
    ])  # Shape (8, 16)
    
    layer_2_weights = np.array([
        [ 0.06383985, -0.16446292,  0.60394984,  0.540713,    0.027714,  -0.3181524,   0.4760818,  -0.13569617],
        [-0.23572193,  0.41630143, -0.53680533, -0.6613103,   0.40882272,  0.50992364,  0.16147399,  0.4276467],
        [ 0.07303502, -0.2354039,  -0.08329785,  0.17838788,  0.03719629,  0.38968703,  0.05384523,  0.38558596],
        [-0.30332395,  0.04194558,  0.19426107, -0.0756467,   0.22533567,  0.49630967, -0.50907606, -0.4160275]
    ])  # Shape (4, 8)
    
    layer_3_weights = np.array([
        [-0.4660369,  0.9587425, -0.6191301, -0.55203765]
    ])  # Shape (1, 4)
    
    # Define biases
    layer_0_biases = np.array([
        [-0.3646018], [0.3285573], [0.29906413], [0.3175617],
        [-0.19215277], [0.38939333], [0.3255394],  [0.0],
        [0.05852522],  [0.0],        [0.31123912], [0.26027152],
        [0.0],         [0.0],        [0.0],        [0.0]
    ])  # Shape (16, 1)
  
    layer_1_biases = np.array([
        [0.0], [-0.2968574], [0.3486964], [0.0],
        [-0.07264236], [0.32530612], [0.0], [0.31865895]
    ])  # Shape (8, 1)
    
    layer_2_biases = np.array([
        [-0.35586578], [0.34539023], [-0.01772358], [0.0]
    ])  # Shape (4, 1)
    
    layer_3_biases = np.array([
        [0.34276724]
    ])  # Shape (1, 1)

    # Perform forward pass
    current_input = input
    current_input = calculate_layer_output(current_input, layer_0_weights.T, layer_0_biases.T, True)
    current_input = calculate_layer_output(current_input, layer_1_weights.T, layer_1_biases.T, True)
    current_input = calculate_layer_output(current_input, layer_2_weights.T, layer_2_biases.T, True)
    current_input = calculate_layer_output(current_input, layer_3_weights.T, layer_3_biases.T, False)
    
    return current_input

# Calculate Nu using the forward pass
Nu = forward_pass(input_data)[0][0]

# Calculate h
h = Nu * k_gas / d_solid

# Print the heat transfer coefficient
print(h)

# End time calculation
end_time = time.time()
print("Time for calculation:", end_time - start_time, "seconds")
